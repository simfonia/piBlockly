工作日誌 (piblockly/work.log)


  日期： 2025年10月18日

  孤兒積木處理與系統優化

  已完成事項：
   * 實現孤兒積木失效邏輯：
       * 在 main.js 中建立了 updateOrphanBlocks 函式，用於處理未連接到根積木（如 setup, loop）的孤兒積木。
       * 經歷多次迭代，最終的邏輯為：在工作區發生變動時，先啟用所有積木，再找出真正的孤兒積木（不被允許的頂層
         積木），並明確地將其本身及其所有子積木都設為停用狀態。

   * 修正 `variables_declare` 積木的根積木規則：
       * 更新了 updateOrphanBlocks 函式，增加了對 variables_declare 積木的特殊判斷。
       * 現在只有當其 SCOPE 欄位為 GLOBAL 時，它才能作為一個合法的根積木存在；若為
         LOCAL，則會被視為孤兒積木而失效。

   * 修正「定義型」積木的連接點問題：
       * 為了解決全域定義積木下方可拼接陳述句積木的邏輯問題，修改了 blocks.js 中的積木定義。
       * `variables_declare`：改為動態形狀，當 SCOPE 為 GLOBAL 時，透過 onchange 事件監聽，以程式碼
         setNextStatement(false) 移除下方接點。
       * `coding_raw_definition`：發現 jsonInit 中使用 "nextStatement": null 無法移除接點，最終透過完全刪除
         `nextStatement` 屬性的方式成功解決了問題。

   * 修正 `coding` 積木的根積木規則：
       * 根據您的最終決策，將 coding_raw_statement 與 coding_raw_wrapper
         從允許的根積木清單中移除，它們現在必須依附於其他積木才能生效。

  解決的重大問題：
   * 修正了無限迴圈導致的系統崩潰：
       * 問題原因：updateOrphanBlocks
         函式會回應「積木改變」事件，但其自身的「停用/啟用」操作又會觸發此事件，導致無限迴圈。
       * 解決方案：修改了 main.js 中的事件監聽器，讓它明確忽略由 disabled
         狀態改變所觸發的事件，從而斬斷了迴圈。

   * 診斷並解決了 `blocks.js` 修改不生效的頑固快取問題：
       * 透過將檔案重新命名 (blocks.js -> blocks_new.js)，確認了問題並非 Webpack 打包或 nonce
         快取清除失敗，而是與檔案本身有關。
       * 在重新命名過程中發現了全形/半形底線的打字錯誤，修正後成功載入新檔案。
       * 最終確認 replace 工具的修改是成功的，但 Blockly 對 jsonInit 中 nextStatement: null
         的解析行為不如預期，必須直接刪除該屬性才能解決問題。


  日期：2025年10月18日

  已完成事項：
   * 修正 Functions 積木的程式碼產生器： 解決了 custom_procedures_defnoreturn 和 custom_procedures_defreturn
     積木在 custom_generator.js 中因換行符逸出問題導致的「Unterminated string literal」錯誤。
   * 新增手動呼叫函式積木： 根據使用者需求，在 toolbox.xml 中新增了 custom_procedures_callnoreturn_manual 和
     custom_procedures_callreturn_manual 積木。
   * 定義手動呼叫函式積木的外觀與行為： 在 media/custom/blocks.js 中定義了
     custom_procedures_callnoreturn_manual 和 custom_procedures_callreturn_manual
     積木，包括函數名稱輸入欄位和參數變異器。
   * 定義手動呼叫函式積木的程式碼產生器： 在 media/custom/custom_generator.js 中定義了
     custom_procedures_callnoreturn_manual 和 custom_procedures_callreturn_manual
     積木的程式碼產生器，使其能正確生成 C++ 函數呼叫。

  討論與解決方案：
   * Functions 積木呼叫問題： 由於 Blockly 預設的 Blockly.Procedures.flyoutCategory
     可能與自訂程序積木不完全相容，且動態生成呼叫積木較為複雜，因此改為提供手動輸入函數名稱的呼叫積木。
   * VSIX 版本更新問題： 說明了 VSIX 版本號碼由 package.json 控制，並提供了更新 VSIX
     的正確步驟（解除安裝舊版、重啟 IDE、安裝新版、再次重啟 IDE）。
   * Blockly 數學函數與 Arduino 相容性： 解釋了 Blockly 的數學函數積木在 Arduino (C++)
     環境中大多可以直接使用，但需注意資料型別和資源限制。


日期： 2025年10月17日
  錯誤訊息：
  第一個積木拉進時，在覆寫警告視窗按yes確定覆蓋時:
  Tried to start the same gesture twice.

  問題分析：
  這個錯誤的根源在於：
   1. 當您拖曳積木時，Blockly 內部會啟動一個「手勢 (gesture)」。
   2. 拖曳積木的動作觸發了 updateCode 事件，進而彈出了「覆寫確認」對話框。
   3. 這個對話框是模態的，它會暫停所有 UI 互動。
   4. 當您點擊「是」關閉對話框後，Blockly
      的手勢系統可能因為被中斷而混亂，導致它嘗試重新啟動一個已經在進行中的手勢，從而拋出錯誤。

  解決方案：
  最直接的解決方法是，在拖曳積木的過程中，不要觸發 `updateCode` 事件。

  Blockly 提供了 workspace.isDragging() 這個方法來判斷目前是否有拖曳手勢正在進行。我將修改 main.js 中的
  updateCode 函式，在發送 updateCode 訊息之前，先檢查 workspace.isDragging()。如果正在拖曳，就暫時不發送更新
  訊息。這樣可以避免對話框在不恰當的時機彈出，干擾手勢。

  
   * 問題描述：Tried to start the same gesture twice 錯誤及積木跳移現象。
   * 根本原因：
       1. Blockly API 變更 (Blockly.Mutator -> Blockly.icons.MutatorIcon)。
       2. validateName_ 函式過早觸發 Blockly.Procedures.rename 導致事件衝突。
       3. domToMutation 函式中錯誤呼叫 Blockly.Procedures.mutateCallers。
       4. Webview 初始化流程與使用者操作之間的競爭條件。
   * 解決方案：
       1. 更新 Blockly.Mutator 的使用方式。
       2. 從 domToMutation 中移除 Blockly.Procedures.mutateCallers 呼叫。
       3. 在 updateCode 函式中加入 workspace.isDragging() 檢查。
       4. 重新設計 Webview 初始化流程，確保 shouldConfirmOverwrite 旗標的正確傳遞與使用。
   * 其他修正：
       * TypeError: Blockly.Xml.textToDom is not a function 的修正。
       * ReferenceError: Cannot access 'shouldConfirmOverwrite' before initialization 的修正。
       * 「無回傳值」函式積木外觀問題的修正。
