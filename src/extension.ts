/**
 * @fileoverview This is the main entry point for the piBlockly VS Code extension.
 * It handles the creation and management of the Blockly webview panel,
 * communication between the extension and the webview, and file I/O for
 * opening and saving Blockly XML projects.
 */
import * as vscode from 'vscode';
import * as fs from 'fs';
import * as path from 'path';
import * as crypto from 'crypto';

const messages = {
    // Error messages
    noArduinoFile: {
        'zh': '請先開啟一個 Arduino (.ino) 檔案，然後再啟動 piBlockly。',
        'en': 'Please open an Arduino (.ino) file first, then start piBlockly.'
    },
    wrongFileType: {
        'zh': (langId: string) => `目前的檔案類型是 '${langId}'，不是 'arduino' 或 'cpp'。請開啟一個 .ino 檔案。`,
        'en': (langId: string) => `Current file type is '${langId}', not 'arduino' or 'cpp'. Please open an .ino file.`
    },
    fileContainsCode: {
        'zh': '偵測到當前檔案包含程式碼。您希望如何處理？',
        'en': 'The current file contains code. How do you want to proceed?'
    },
    overwriteCode: {
        'zh': '覆蓋現有程式碼',
        'en': 'Overwrite existing code'
    },
    // Quick pick options
    newProject: {
        'zh': '新增專案',
        'en': 'New Project'
    },
    openProject: {
        'zh': '開啟專案',
        'en': 'Open Project'
    },
    newProjectDescription: {
        'zh': '建立一個新專案並儲存 .xml 檔案',
        'en': 'Create a new project and save the .xml file'
    },
    openProjectDescription: {
        'zh': '開啟一個現有的 .xml 專案檔',
        'en': 'Open an existing .xml project file'
    },
    newOrExistingProject: {
        'zh': '要建立新專案還是開啟現有專案？',
        'en': 'Do you want to create a new project or open an existing one?'
    },
    // Error messages
    loadProjectFailed: {
        'zh': (error: string) => `載入專案檔失敗：${error}`,
        'en': (error: string) => `Failed to load project file: ${error}`
    },
    noActiveEditor: {
        'zh': '沒有作用中的文字編輯器，無法建立 piBlockly 面板。',
        'en': 'No active text editor, cannot create piBlockly panel.'
    },
    noXmlPath: {
        'zh': '沒有提供 XML 檔案路徑，無法建立 piBlockly 面板。',
        'en': 'No XML file path provided, cannot create piBlockly panel.'
    },
    codeManuallyModified: {
        'zh': '偵測到程式碼已被手動修改。繼續生成將會覆蓋您的修改。是否繼續？',
        'en': 'Code has been manually modified. Continuing will overwrite your changes. Do you want to continue?'
    },
    continueOverwrite: {
        'zh': '繼續覆蓋',
        'en': 'Continue Overwrite'
    },
    updateCodeFailed: {
        'zh': (error: string) => `更新程式碼失敗：${error}`,
        'en': (error: string) => `Failed to update code: ${error}`
    },
    projectSaved: {
        'zh': (filename: string) => `專案已儲存至 ${filename}`,
        'en': (filename: string) => `Project saved to ${filename}`
    },
    saveProjectFailed: {
        'zh': (error: string) => `儲存專案失敗：${error}`,
        'en': (error: string) => `Failed to save project: ${error}`
    },
    unsavedChanges: {
        'zh': '您在 piBlockly 中有未儲存的變更。是否要儲存？',
        'en': 'You have unsaved changes in piBlockly. Do you want to save?'
    },
    save: {
        'zh': '儲存',
        'en': 'Save'
    },
    doNotSave: {
        'zh': '不儲存',
        'en': 'Don\'t Save'
    },
    cancel: {
        'zh': '取消',
        'en': 'Cancel'
    },
    openBlocklyXml: {
        'zh': '開啟 Blockly XML',
        'en': 'Open Blockly XML'
    },
    blocklyXmlFiles: {
        'zh': 'Blockly XML 檔案',
        'en': 'Blockly XML Files'
    },
    confirmOverwriteExistingFile: {
        'zh': (filename: string) => `${filename} 已存在，您要取代它嗎？`,
        'en': (filename: string) => `${filename} already exists. Do you want to replace it?`
    },
    replace: {
        'zh': '取代',
        'en': 'Replace'
    },
    cancelOverwrite: { // Using a different key to avoid conflict with general 'cancel'
        'zh': '取消',
        'en': 'Cancel'
    }
};

function getLocalizedMessage(key: keyof typeof messages, ...args: any[]): string {
    const locale = vscode.env.language;
    const isChinese = locale.startsWith('zh');
    const lang = isChinese ? 'zh' : 'en';

    // Fallback to English if a translation for the current language is missing
    const messageOrFn = messages[key][lang] || messages[key].en;

    if (typeof messageOrFn === 'function') {
        // Cast to a generic function signature to satisfy the spread operator
        return (messageOrFn as (...a: any[]) => string)(...args);
    }
    
    return messageOrFn;
}

/**
 * Defines the state of the currently active piBlockly webview panel.
 */
interface PiBlocklyPanel {
    /** The webview panel itself. */
    panel: vscode.WebviewPanel;
    /** The URI of the .ino file associated with the panel, as a string. */
    associatedUriString: string;
    /** The full file path of the currently loaded .xml project file. */
    xmlName: string;
    /** A flag indicating if the webview has unsaved changes. */
    isDirty: boolean;
    /** A hash of the last code generated by Blockly to detect manual edits. */
    lastGeneratedCodeHash: string;
}

/**
 * Holds the single, currently active piBlockly panel.
 * The extension is designed to only allow one panel to be open at a time.
 */
let currentPanel: PiBlocklyPanel | undefined;


/**
 * The main activation function for the extension.
 * This is called by VS Code when the extension is activated.
 * It sets up the commands and event listeners.
 * @param context The extension context provided by VS Code.
 */
export function activate(context: vscode.ExtensionContext) {

    // Set a context key that can be used in 'when' clauses in package.json
    vscode.commands.executeCommand('setContext', 'piblockly.panelOpen', false);

    // Register the command that starts the piBlockly editor.
    const startCommand = vscode.commands.registerCommand('piblockly.start', async () => {

        const editor = vscode.window.activeTextEditor;
        if (!editor) {
            vscode.window.showErrorMessage(getLocalizedMessage('noArduinoFile'));
            return;
        }

        const languageId = editor.document.languageId;
        if (languageId !== 'arduino' && languageId !== 'cpp') {
            vscode.window.showErrorMessage(getLocalizedMessage('wrongFileType', languageId));
            return;
        }

        // Warn the user if the associated .ino file is not empty.
        const currentContent = editor.document.getText();
        if (currentContent.trim().length > 0) { // Check if file is not empty
            const overwriteChoice = await vscode.window.showWarningMessage(
                getLocalizedMessage('fileContainsCode'),
                { modal: true },
                getLocalizedMessage('overwriteCode')
            );

            if (overwriteChoice !== getLocalizedMessage('overwriteCode')) {
                // User chose '取消' or closed the dialog
                return;
            }
        }

        // Prompt the user to either create a new project or open an existing one.
        const choice = await vscode.window.showQuickPick([
            { label: getLocalizedMessage('newProject'), description: getLocalizedMessage('newProjectDescription') },
            { label: getLocalizedMessage('openProject'), description: getLocalizedMessage('openProjectDescription') }
        ], {
            placeHolder: getLocalizedMessage('newOrExistingProject')
        });

        if (!choice) { return; }


        if (choice.label === getLocalizedMessage('newProject')) {
            await handleNewProject(context, editor);
        } else { // Open an existing project
            await handleOpenProject(context, editor);
        }
    });

    // Register an event listener to automatically close the webview panel
    // if its associated .ino or .xml file is closed.
    const onDidCloseDocumentSubscription = vscode.workspace.onDidCloseTextDocument(async (document) => {
        if (!currentPanel) {
            return;
        }
        const closedUriString = document.uri.toString();
        const panelXmlUriString = vscode.Uri.file(currentPanel.xmlName).toString();

        if (currentPanel.associatedUriString === closedUriString || panelXmlUriString === closedUriString) {
            // The associated .ino or .xml file was closed.
            // We pass `false` for canCancel because the document is already gone.
            closePanel(currentPanel.panel, false);
        }
    });

    // Register an event listener to show/hide an overlay on the webview
    // if its associated editor is not visible.
    const onDidChangeVisibleEditorsSubscription = vscode.window.onDidChangeVisibleTextEditors(editors => {
        if (!currentPanel) {
            return;
        }
        const isAssociatedEditorVisible = editors.some(editor => editor.document.uri.toString() === currentPanel!.associatedUriString);

        if (isAssociatedEditorVisible) {
            currentPanel.panel.webview.postMessage({ command: 'panelActive' });
        } else {
            currentPanel.panel.webview.postMessage({ command: 'panelInactive' });
        }
    });

    context.subscriptions.push(startCommand, onDidCloseDocumentSubscription, onDidChangeVisibleEditorsSubscription);
}

async function handleNewProject(context: vscode.ExtensionContext, editor: vscode.TextEditor) {
    if (currentPanel) {
        const canProceed = await closePanel(currentPanel.panel, true);
        if (!canProceed) {
            return; // User cancelled closing the current panel
        }
    }

    // Prompt for a file path to save the new XML.
    const saveOptions: vscode.SaveDialogOptions = {
        filters: { [getLocalizedMessage('blocklyXmlFiles')]: ['xml'] }
    };
    const xmlUri = await vscode.window.showSaveDialog(saveOptions);
    if (!xmlUri) { return; }

    // Create default XML content for a new project.
    const xmlContent = `
<xml xmlns="https://developers.google.com/blockly/xml">
  <block type="initializes_setup" id="setup_block" x="100" y="50">
    <next>
      <block type="initializes_loop" id="loop_block"></block>
    </next>
  </block>
</xml>
`;

    fs.writeFileSync(xmlUri.fsPath, xmlContent);
    const xmlName = xmlUri.fsPath;
    createAndShowPanel(context, xmlContent, xmlName, editor);
}

async function handleOpenProject(context: vscode.ExtensionContext, editor: vscode.TextEditor) {
    if (currentPanel) {
        const canProceed = await closePanel(currentPanel.panel, true);
        if (!canProceed) {
            return; // User cancelled closing the current panel
        }
    }

    const openOptions: vscode.OpenDialogOptions = {
        canSelectMany: false,
        openLabel: getLocalizedMessage('openBlocklyXml'),
        filters: { [getLocalizedMessage('blocklyXmlFiles')]: ['xml'] }
    };
    const selectedFiles = await vscode.window.showOpenDialog(openOptions);
    if (!selectedFiles || selectedFiles.length === 0) { return; }

    try {
        const xmlName = selectedFiles[0].fsPath;
        const xmlContent = fs.readFileSync(xmlName, 'utf8');
        createAndShowPanel(context, xmlContent, xmlName, editor);
    } catch (error: any) {
        vscode.window.showErrorMessage(getLocalizedMessage('loadProjectFailed', String(error)));
        return;
    }
}

/**
 * Creates and shows the piBlockly webview panel.
 * @param context The extension context.
 * @param xmlContent The initial XML content to load into the Blockly workspace.
 * @param xmlName The full path of the associated .xml file.
 */
async function createAndShowPanel(context: vscode.ExtensionContext, xmlContent: string, xmlName: string | undefined, editor: vscode.TextEditor) {
    if (!xmlName) {
        vscode.window.showErrorMessage(getLocalizedMessage('noXmlPath'));
        return;
    }

    const associatedUriString = editor.document.uri.toString();

    // Create the webview panel in the second view column.
    const panel = vscode.window.createWebviewPanel(
        'piblocklyEditor',
        `piBlockly: ${path.basename(xmlName)}`,
        vscode.ViewColumn.Two,
        {
            enableScripts: true,
            // Restrict the webview to only loading resources from our extension's media directories.
            localResourceRoots: [
                vscode.Uri.joinPath(context.extensionUri, 'media'),
                vscode.Uri.joinPath(context.extensionUri, 'node_modules'),
                vscode.Uri.joinPath(context.extensionUri, 'media', 'user_modules') // Allow access to user_modules
            ],
            enableForms: true, // Required for Blockly dialogs
            retainContextWhenHidden: true // Keep the webview state even when not visible
        }
    );

    // Store the state of the new panel.
    currentPanel = {
        panel: panel,
        associatedUriString: associatedUriString,
        xmlName: xmlName,
        isDirty: false,
        lastGeneratedCodeHash: crypto.createHash('sha256').update(editor.document.getText()).digest('hex')
    };

    // Update the context key to indicate that a panel is open.
    vscode.commands.executeCommand('setContext', 'piblockly.panelOpen', true);

    // Set up a listener to clean up when the panel is disposed (e.g., by the user closing it).
    panel.onDidDispose(() => {
        currentPanel = undefined;
        vscode.commands.executeCommand('setContext', 'piblockly.panelOpen', false);
    }, null, context.subscriptions);



    // Set the webview's initial HTML content.
    panel.webview.html = await getWebviewContent(panel.webview, context.extensionUri, context.extensionPath);

    // Handle messages from the webview.
    panel.webview.onDidReceiveMessage(
        async message => {
            if (!currentPanel) { return; } // Should not happen if panel is visible

            const associatedEditor = vscode.window.visibleTextEditors.find(e => e.document.uri.toString() === currentPanel!.associatedUriString);

            switch (message.command) {
                // The webview is ready to receive the initial workspace XML.
                case 'webviewReady':
                    panel.webview.postMessage({ command: 'initializeWorkspace', xml: xmlContent, inoUri: currentPanel.associatedUriString, xmlName: currentPanel.xmlName });
                    return;
                
                // The webview has sent updated Arduino code to be written to the .ino file.
                case 'updateCode':
                    if (associatedEditor) {
                        const code = message.code;
                        try {
                            const doc = associatedEditor.document;
                            const currentContent = doc.getText();
                            const currentHash = crypto.createHash('sha256').update(currentContent).digest('hex');

                            // Check if the user has manually edited the .ino file since the last code generation.
                            if (currentPanel.lastGeneratedCodeHash && currentHash !== currentPanel.lastGeneratedCodeHash) {
                                                            const overwriteChoice = await vscode.window.showWarningMessage(
                                                                getLocalizedMessage('codeManuallyModified'),
                                                                { modal: true },
                                                                getLocalizedMessage('continueOverwrite')
                                                            );                                if (overwriteChoice !== '繼續覆蓋') {
                                    return; // User cancelled
                                }
                            }

                            // Apply the new code to the editor.
                            const edit = new vscode.WorkspaceEdit();
                            const fullRange = new vscode.Range(doc.positionAt(0), doc.positionAt(doc.getText().length));
                            edit.replace(doc.uri, fullRange, code);
                            await vscode.workspace.applyEdit(edit);

                            // Update the hash to reflect the new content.
                            currentPanel.lastGeneratedCodeHash = crypto.createHash('sha256').update(code).digest('hex');

                        } catch (error) {
                            vscode.window.showErrorMessage(getLocalizedMessage('updateCodeFailed', String(error)));
                        }
                    }
                    return;
                
                // The webview is requesting a prompt (e.g., for variable creation).
                case 'prompt':
                    const input = await vscode.window.showInputBox({ prompt: message.message, value: message.defaultValue });
                    panel.webview.postMessage({ command: 'promptResponse', value: input });
                    return;

                // The webview is requesting a confirmation dialog.
                case 'confirm':
                    const choice = await vscode.window.showWarningMessage(message.message, { modal: true }, '是', '否');
                    panel.webview.postMessage({ command: 'confirmResponse', value: choice === '是' });
                    return;

                // The webview has reported a block selection.
                case 'selectBlock':
                    if (associatedEditor) {
                        const scope = message.scope;
                        const document = associatedEditor.document;
                        let targetLine = 0; // Default to top of file for global or unknown scope

                        // Helper function to escape strings for use in a regular expression.
                        const escapeRegExp = (str: string) => {
                            return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); // $& means the whole matched string
                        };

                        if (scope === 'setup') {
                            const match = document.getText().match(/^void\s+setup\s*\(\s*\)\s*\{/m);
                            if (match && match.index !== undefined) {
                                targetLine = document.positionAt(match.index).line;
                            }
                        } else if (scope === 'loop') {
                            const match = document.getText().match(/^void\s+loop\s*\(\s*\)\s*\{/m);
                            if (match && match.index !== undefined) {
                                targetLine = document.positionAt(match.index).line;
                            }
                        } else if (scope.startsWith('function:')) {
                            const functionName = scope.substring('function:'.length);
                            const escapedFuncName = escapeRegExp(functionName);
                            // This more flexible regex allows for any valid C++-like type, including pointers and custom classes.
                            const regex = new RegExp(`^([a-zA-Z_][a-zA-Z0-9_\\*\\s&]*?)\\s+${escapedFuncName}\\s*\\([^)]*\\)\\s*\\{`, 'm');
                            const match = document.getText().match(regex);
                            if (match && match.index !== undefined) {
                                targetLine = document.positionAt(match.index).line;
                            }
                        }
                        // If scope is 'global' or not found, targetLine remains 0.

                        const range = new vscode.Range(targetLine, 0, targetLine, 0);
                        associatedEditor.revealRange(range, vscode.TextEditorRevealType.AtTop);
                    }
                    return;
                
                // The webview is reporting a change in its "dirty" state (unsaved changes).
                case 'dirtyStateChanged':
                    currentPanel.isDirty = message.isDirty;
                    return;

                // The webview is requesting to save the project.
                case 'saveProject':
                    {
                        const currentXmlName = currentPanel.xmlName;
                        if (currentXmlName) {
                            try {
                                fs.writeFileSync(currentXmlName, message.xml);
                                vscode.window.showInformationMessage(getLocalizedMessage('projectSaved', path.basename(currentXmlName)));
                                panel.webview.postMessage({ command: 'saveComplete' });
                            } catch (error: any) {
                                vscode.window.showErrorMessage(getLocalizedMessage('saveProjectFailed', String(error)));
                            }
                        } else {
                            // This case should ideally not be hit if a project is always created/opened first,
                            // but it's here as a fallback to trigger "Save As".
                            const options: vscode.SaveDialogOptions = {
                                filters: { 'Blockly XML': ['xml'] }
                            };
                            if (associatedEditor) {
                                options.defaultUri = associatedEditor.document.uri.with({ path: associatedEditor.document.uri.path.replace(/(\.[^/.]+)?$/, '.xml') });
                            }

                            const fileUriToSave = await vscode.window.showSaveDialog(options);
                            if (fileUriToSave) {
                                try {
                                    fs.writeFileSync(fileUriToSave.fsPath, message.xml);
                                    currentPanel.xmlName = fileUriToSave.fsPath;
                                    panel.title = `piBlockly: ${path.basename(fileUriToSave.fsPath)}`;
                                    vscode.window.showInformationMessage(getLocalizedMessage('projectSaved', path.basename(fileUriToSave.fsPath)));
                                    panel.webview.postMessage({ command: 'saveComplete' });
                                } catch (error: any) {
                                    vscode.window.showErrorMessage(getLocalizedMessage('saveProjectFailed', String(error)));
                                }
                            }
                        }
                    }
                    return;

                // The webview is requesting to "Save As" the project.
                case 'saveProjectAs':
                    {
                        const options: vscode.SaveDialogOptions = {
                            filters: { 'Blockly XML': ['xml'] }
                        };
                        const currentXmlName = currentPanel.xmlName;
                        if (currentXmlName) {
                            options.defaultUri = vscode.Uri.file(currentXmlName);
                        } else if (associatedEditor) {
                            options.defaultUri = associatedEditor.document.uri.with({ path: associatedEditor.document.uri.path.replace(/(\.[^/.]+)?$/, '.xml') });
                        }

                        const fileUriToSave = await vscode.window.showSaveDialog(options);
                        if (fileUriToSave) {
                            try {
                                fs.writeFileSync(fileUriToSave.fsPath, message.xml);
                                currentPanel.xmlName = fileUriToSave.fsPath;
                                panel.title = `piBlockly: ${path.basename(fileUriToSave.fsPath)}`;
                                vscode.window.showInformationMessage(getLocalizedMessage('projectSaved', path.basename(fileUriToSave.fsPath)));
                                panel.webview.postMessage({ command: 'saveComplete' });
                            } catch (error: any) {
                                vscode.window.showErrorMessage(getLocalizedMessage('saveProjectFailed', String(error)));
                            }
                        }
                    }
                    return;
                
                // The webview is requesting to be closed.
                case 'closeEditor':
                    closePanel(panel, true);
                    return;
                
                case 'newProject': {
                    if (!currentPanel) {return;}
                    const associatedEditor = vscode.window.visibleTextEditors.find(e => e.document.uri.toString() === currentPanel!.associatedUriString);
                    if (!associatedEditor) {
                        vscode.window.showErrorMessage(getLocalizedMessage('noActiveEditor'));
                        return;
                    }

                    const currentContent = associatedEditor.document.getText();
                    if (currentContent.trim().length > 0) {
                        const overwriteChoice = await vscode.window.showWarningMessage(
                            getLocalizedMessage('fileContainsCode'),
                            { modal: true },
                            getLocalizedMessage('overwriteCode')
                        );
                        if (overwriteChoice !== getLocalizedMessage('overwriteCode')) {
                            return;
                        }
                    }
                    await handleNewProject(context, associatedEditor);
                    return;
                }

                case 'openProject': {
                    if (!currentPanel) {return;}
                    const associatedEditor = vscode.window.visibleTextEditors.find(e => e.document.uri.toString() === currentPanel!.associatedUriString);
                    if (!associatedEditor) {
                        vscode.window.showErrorMessage(getLocalizedMessage('noActiveEditor'));
                        return;
                    }
                    
                    const currentContent = associatedEditor.document.getText();
                    if (currentContent.trim().length > 0) {
                        const overwriteChoice = await vscode.window.showWarningMessage(
                            getLocalizedMessage('fileContainsCode'),
                            { modal: true },
                            getLocalizedMessage('overwriteCode')
                        );
                        if (overwriteChoice !== getLocalizedMessage('overwriteCode')) {
                            return;
                        }
                    }
                    await handleOpenProject(context, associatedEditor);
                    return;
                }
            }
        },
        undefined,
        context.subscriptions
    );
}

/**
 * Handles the logic for closing the webview panel, including prompting for unsaved changes.
 * @param panel The webview panel to close.
 * @param canCancel Whether the closing action can be cancelled by the user.
 */
async function closePanel(panel: vscode.WebviewPanel, canCancel: boolean): Promise<boolean> {
    if (!currentPanel) { return true; } // No panel open, so effectively "closed"
    const isDirty = currentPanel.isDirty;

    if (isDirty) {
        const message = getLocalizedMessage('unsavedChanges');
        const options: vscode.MessageOptions = { modal: true };
        const items = [getLocalizedMessage('save'), getLocalizedMessage('doNotSave')];
        if (canCancel) {
            // VS Code's showWarningMessage with modal:true often provides an implicit cancel.
            // We rely on that implicit cancel (which results in 'choice' being undefined).
            // So, we don't add an explicit 'cancel' button here.
        }

        const choice = await vscode.window.showWarningMessage(message, options, ...items);

        if (choice === getLocalizedMessage('save')) {
            // This is a complex flow: we ask the webview for the XML,
            // wait for its 'saveProject' response, save the file, and then dispose the panel.
            return await new Promise<boolean>(resolve => {
                const sub = panel.webview.onDidReceiveMessage(async (message) => {
                    if (message.command === 'saveProject') {
                        sub.dispose(); // Stop listening for this message.

                        const currentXmlName = currentPanel!.xmlName;
                        if (currentXmlName) {
                            try {
                                fs.writeFileSync(currentXmlName, message.xml);
                                vscode.window.showInformationMessage(getLocalizedMessage('projectSaved', path.basename(currentXmlName)));
                                panel.webview.postMessage({ command: 'saveComplete' });
                                panel.dispose();
                                resolve(true);
                            } catch (error: any) {
                                vscode.window.showErrorMessage(getLocalizedMessage('saveProjectFailed', String(error)));
                                resolve(false); // Save failed
                            }
                        } else {
                            // Fallback to "Save As" if no name is associated.
                            const options: vscode.SaveDialogOptions = {
                                filters: { [getLocalizedMessage('blocklyXmlFiles')]: ['xml'] }
                            };
                            const fileUriToSave = await vscode.window.showSaveDialog(options);
                            if (fileUriToSave) {
                                try {
                                    fs.writeFileSync(fileUriToSave.fsPath, message.xml);
                                    currentPanel!.xmlName = fileUriToSave.fsPath;
                                    panel.title = `piBlockly: ${path.basename(fileUriToSave.fsPath)}`;
                                    vscode.window.showInformationMessage(getLocalizedMessage('projectSaved', path.basename(fileUriToSave.fsPath)));
                                    panel.webview.postMessage({ command: 'saveComplete' });
                                    panel.dispose();
                                    resolve(true);
                                } catch (error: any) {
                                    vscode.window.showErrorMessage(getLocalizedMessage('saveProjectFailed', String(error)));
                                    resolve(false); // Save failed
                                }
                            } else {
                                resolve(false); // User cancelled save as dialog
                            }
                        }
                    }
                });
                // Request the XML from the webview.
                panel.webview.postMessage({ command: 'requestSave' });
            });
        } else if (choice === getLocalizedMessage('doNotSave')) {
            panel.dispose();
            return true;
        } else { // 'cancel' or undefined (dialog closed)
            return false;
        }
    } else { // Not dirty, just close it.
        panel.dispose();
        return true;
    }
}

/**
 * Generates a random nonce for use in the webview's Content Security Policy.
 * @returns A 32-character random string.
 */
function getNonce() {
    let text = '';
    const possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    for (let i = 0; i < 32; i++) {
        text += possible.charAt(Math.floor(Math.random() * possible.length));
    }
    return text;
}

/**
 * Generates the complete HTML content for the webview panel.
 * @param webview The webview instance.
 * @param extensionUri The URI of the extension's root directory.
 * @param extensionPath The file path of the extension's root directory.
 * @returns The full HTML string for the webview.
 */
async function getWebviewContent(webview: vscode.Webview, extensionUri: vscode.Uri, extensionPath: string) {
    const mediaPath = vscode.Uri.joinPath(extensionUri, 'media');
    const nonce = getNonce();

    // Determine which language files to load based on VS Code's locale
    const locale = vscode.env.language;
    let blocklyLangFilePath; // Path for core blockly language file relative to extension root
    let customLangFilePath;  // Path for custom language file relative to media folder

    if (locale.startsWith('zh')) { // Covers 'zh-tw', 'zh-cn', etc.
        blocklyLangFilePath = 'node_modules/blockly/msg/zh-hant.js';
        customLangFilePath = 'zh-hant.js';
    } else {
        blocklyLangFilePath = 'node_modules/blockly/msg/en.js';
        customLangFilePath = 'en.js';
    }

    const styleUri = webview.asWebviewUri(vscode.Uri.joinPath(mediaPath, 'style.css')).with({ query: `nonce=${nonce}` });
    const blocklyUri = webview.asWebviewUri(vscode.Uri.joinPath(mediaPath, 'blockly', 'core', 'blockly.js')).with({ query: `nonce=${nonce}` });
    const langUri = webview.asWebviewUri(vscode.Uri.joinPath(extensionUri, blocklyLangFilePath)).with({ query: `nonce=${nonce}` });
    const customLangUri = webview.asWebviewUri(vscode.Uri.joinPath(mediaPath, customLangFilePath)).with({ query: `nonce=${nonce}` });
    const coreGeneratorUri = webview.asWebviewUri(vscode.Uri.joinPath(mediaPath, 'generators', '_core.js')).with({ query: `nonce=${nonce}` });
    const libGeneratorUri = webview.asWebviewUri(vscode.Uri.joinPath(mediaPath, 'generators', '_lib.js')).with({ query: `nonce=${nonce}` });
    const fieldColourUri = webview.asWebviewUri(vscode.Uri.joinPath(mediaPath, 'blockly', 'plugins', 'field-colour.js')).with({ query: `nonce=${nonce}` });
    const fieldMultilineInputUri = webview.asWebviewUri(vscode.Uri.joinPath(mediaPath, 'blockly', 'plugins', 'field-multilineinput.js')).with({ query: `nonce=${nonce}` });
    const mainUri = webview.asWebviewUri(vscode.Uri.joinPath(mediaPath, 'main.js')).with({ query: `nonce=${nonce}` });
    const manifestUri = webview.asWebviewUri(vscode.Uri.joinPath(mediaPath, 'manifest.json')).with({ query: `nonce=${nonce}` });
    const userModulesConfigUri = webview.asWebviewUri(vscode.Uri.joinPath(mediaPath, 'user_modules', 'user_modules_config.json')).with({ query: `nonce=${nonce}` });

    // Read the content of the custom language file to get toolbar translations
    const customLangPath = path.join(extensionPath, 'media', customLangFilePath);
    const customLangContent = await fs.promises.readFile(customLangPath, 'utf8');

    const messages: { [key: string]: string } = {};
    const regex = /"([^\"]+)":\s*"([^\"]*)"/g;
    let match;
    while ((match = regex.exec(customLangContent)) !== null) {
        messages[match[1]] = match[2];
    }

    const saveTooltip = messages['BKY_TOOLBAR_SAVE_TOOLTIP'] || '';
    const saveAsTooltip = messages['BKY_TOOLBAR_SAVE_AS_TOOLTIP'] || '';
    const closeTooltip = messages['BKY_TOOLBAR_CLOSE_TOOLTIP'] || '';
    const newTooltip = messages['BKY_TOOLBAR_NEW_TOOLTIP'] || '';
    const openTooltip = messages['BKY_TOOLBAR_OPEN_TOOLTIP'] || '';
    const engineerLabel = messages['BKY_TOOLBAR_ENGINEER_LABEL'] || '';
    const angelLabel = messages['BKY_TOOLBAR_ANGEL_LABEL'] || '';
    const saveIconUri = webview.asWebviewUri(vscode.Uri.joinPath(mediaPath, 'icons', 'save_24dp_1F1F1F.svg'));
    const saveAsIconUri = webview.asWebviewUri(vscode.Uri.joinPath(mediaPath, 'icons', 'save_as_24dp_1F1F1F.svg'));
    const dangerousIconUri = webview.asWebviewUri(vscode.Uri.joinPath(mediaPath, 'icons', 'dangerous_24dp_1F1F1F.svg'));
    const newIconUri = webview.asWebviewUri(vscode.Uri.joinPath(mediaPath, 'icons', 'new_24dp_1F1F1F.svg'));
    const openIconUri = webview.asWebviewUri(vscode.Uri.joinPath(mediaPath, 'icons', 'open_24dp_1F1F1F.svg'));
    const saveIconHoverUri = webview.asWebviewUri(vscode.Uri.joinPath(mediaPath, 'icons', 'save_24dp_FE2F89.svg'));
    const saveAsIconHoverUri = webview.asWebviewUri(vscode.Uri.joinPath(mediaPath, 'icons', 'save_as_24dp_FE2F89.svg'));
    const dangerousIconHoverUri = webview.asWebviewUri(vscode.Uri.joinPath(mediaPath, 'icons', 'dangerous_24dp_FE2F89.svg'));
    const newIconHoverUri = webview.asWebviewUri(vscode.Uri.joinPath(mediaPath, 'icons', 'new_24dp_FE2F89.svg'));
    const openIconHoverUri = webview.asWebviewUri(vscode.Uri.joinPath(mediaPath, 'icons', 'open_24dp_FE2F89.svg'));

    const toolboxPath = path.join(extensionPath, 'media', 'toolbox.xml');
    const toolboxXml = await fs.promises.readFile(toolboxPath, 'utf8');


    return `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    
    <meta http-equiv="Content-Security-Policy" content="default-src 'none'; media-src 'none'; style-src ${webview.cspSource} 'unsafe-inline'; img-src ${webview.cspSource} data: https: vscode-webview-resource:; script-src 'nonce-${nonce}' ${webview.cspSource} vscode-webview-resource: blob:; connect-src ${webview.cspSource} vscode-webview-resource:;">

    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>piBlockly 編輯器</title>
    <style>
        #loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 2em;
            z-index: 1000;
        }
        #inactive-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            color: white;
            display: none; /* Initially hidden */
            justify-content: center;
            align-items: center;
            font-size: 2em;
            z-index: 1000;
        }
        #toolbar {
            padding: 5px;
            background-color: #f0f0f0;
            border-bottom: 1px solid #ccc;
            display: flex;
            align-items: center;
        }
        #toolbar img {
            cursor: pointer;
            width: 24px;
            height: 24px;
            margin-right: 10px;
        }
        #closeButton {
            margin-left: auto; /* Pushes the button to the right */
        }
        /* Theme Switch Styles */
        .theme-switch-wrapper {
            display: flex;
            align-items: center;
            margin-left: 20px; /* Adjust as needed */
            font-size: 0.9em;
            color: #555;
        }
        .theme-switch {
            display: inline-block;
            height: 24px;
            position: relative;
            width: 48px;
            margin: 0 10px;
        }
        .theme-switch input {
            display: none;
        }
        .slider {
            background-color: #ccc;
            bottom: 0;
            cursor: pointer;
            left: 0;
            position: absolute;
            right: 0;
            top: 0;
            transition: .4s;
        }
        .slider:before {
            background-color: #fff;
            bottom: 4px;
            content: "";
            height: 16px;
            left: 4px;
            position: absolute;
            transition: .4s;
            width: 16px;
        }
        input:checked + .slider {
            background-color: #2196F3; /* A neutral blue for the "on" state */
        }
        input:checked + .slider:before {
            transform: translateX(24px);
        }
        .slider.round {
            border-radius: 24px;
        }
        .slider.round:before {
            border-radius: 50%;
        }
    </style>
    <link href="${styleUri}" rel="stylesheet">
</head>
<body>
    <div id="loading-overlay">載入中...</div>
    <div id="inactive-overlay" style="display: none; justify-content: center; align-items: center; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.5); color: white; font-size: 2em; z-index: 1000; text-align: center; padding: 20px;"></div>
    <div id="toolbar">
        <img id="newButton" src="${newIconUri}" data-src="${newIconUri}" data-hover-src="${newIconHoverUri}" alt="${newTooltip}" title="${newTooltip}">
        <img id="openButton" src="${openIconUri}" data-src="${openIconUri}" data-hover-src="${openIconHoverUri}" alt="${openTooltip}" title="${openTooltip}">
        <img id="saveButton" src="${saveIconUri}" data-src="${saveIconUri}" data-hover-src="${saveIconHoverUri}" alt="${saveTooltip}" title="${saveTooltip}">
        <img id="saveAsButton" src="${saveAsIconUri}" data-src="${saveAsIconUri}" data-hover-src="${saveAsIconHoverUri}" alt="${saveAsTooltip}" title="${saveAsTooltip}">
        <div class="theme-switch-wrapper">
            <label>${engineerLabel}</label>
            <label class="theme-switch">
                <input type="checkbox" id="themeToggle">
                <span class="slider round"></span>
            </label>
            <label>${angelLabel}</label>
        </div>
        <img id="closeButton" src="${dangerousIconUri}" data-src="${dangerousIconUri}" data-hover-src="${dangerousIconHoverUri}" alt="${closeTooltip}" title="${closeTooltip}">
    </div>
    <div id="blocklyDiv" style="height: calc(100vh - 40px); width: 100vw;"></div>

    <script id="toolbox-xml" type="text/xml" style="display: none;">${`<xml>${toolboxXml}</xml>`}</script>

    <script nonce="${nonce}" src="${blocklyUri}"></script>
    <script nonce="${nonce}" src="${langUri}"></script>
    <script nonce="${nonce}" src="${customLangUri}"></script>
    <script nonce="${nonce}" src="${coreGeneratorUri}"></script>
    <script nonce="${nonce}" src="${libGeneratorUri}"></script>
    <script nonce="${nonce}" src="${fieldColourUri}"></script>
    <script nonce="${nonce}" src="${fieldMultilineInputUri}"></script>



    <script nonce="${nonce}">
        window.manifestUri = "${manifestUri}";
        window.userModulesConfigUri = "${userModulesConfigUri}";
        window.currentLocale = "${locale}"; // Pass the current locale
    </script>
    <script nonce="${nonce}" type="module" src="${mainUri}"></script>
</body>
</html>`;
}

export function deactivate() {}